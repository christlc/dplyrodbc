---
output:
  md_document:
    variant: markdown_github
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r, echo = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "README-"
)
```

## dplyrodbc

```{r,eval=FALSE}
devtools::install_github("mdsumner/RODBCDBI",   ref = "mike")
```


## Example

ODBC has an installed File DSN called "CountriesAccess". This is a .mdb file created using 32-bit Windows (effectively) and configured with the Data Sources application from "C:\\Windows\\SysWOW64\\odbcad32.exe". 

Minimal test for RODBC. 

```{r}
library(RODBC)  ## remember this is 32-bit R
con <- odbcConnect("CountriesAccess1")
## some columns explode the app, presumably "Geom (I)"
sqlQuery(con, "SELECT TOP 10 * FROM [Countries Table]")
close(con)
```

Methods for us. 

```{r}

src_access <- function(dbname = NULL, host = NULL, port = NULL, user = NULL,
                         password = NULL, ...) {

  con <-    dbConnect(RODBCDBI::ODBC(), dsn=dbname)

  src_sql("access", con)
}



src_desc.src_access <- function(con) {
  info <- dbGetInfo(con$con)
  host <- if (info$host == "") "localhost" else info$host

  paste0("Access ", info$serverVersion, " [", info$user, "@",
    host, ":", info$port, "/", info$dbname, "]")
}


db_list_tables.src_access <- function(con) {
  dbListTables(con$con)
}

db_has_table.src_access <- function(con, table) {
  dbExistsTable(con$con, table)
}

tbl.src_access <- function(src, from, ...) {
  tbl_sql("access", src = src, from = from, ...)
}

src_translate_env.src_access <- dplyr:::src_translate_env.NULL

sql_squote <- 
function (x) 
{
 # y <- gsub(quote, paste0(quote, quote), x, fixed = TRUE)
  y <- paste0("[", x, "]")
  y[is.na(x)] <- "NULL"
  names(y) <- names(x)
  y
}

sql_escape_string.ODBCConnection <- function(con, x) {
   sql_squote(x)
}

sql_escape_ident.ODBCConnection<- function(con, x) {
  sql_squote(x)
}


## crucial part, since our ODBC source uses TOP instead of LIMIT
sql_select.ODBCConnection <- 
function (con, select, from, where = NULL, group_by = NULL, having = NULL, 
    order_by = NULL, limit = NULL, offset = NULL, ...) 
{
    out <- vector("list", 8)
    names(out) <- c("select", "from", "where", "group_by", "having", 
        "order_by", "limit", "offset")
    assertthat::assert_that(is.character(select), length(select) > 0L)
    
   
        if (!is.null(limit)) {
          assertthat::assert_that(is.integer(limit), length(limit) == 1L)
          ## TOP clause is part of SELECT
           out$select <- build_sql("SELECT ", " TOP ", limit, " ",  escape(select, collapse = ", ", 
        con = con))
        } else {
    
      out$select <- build_sql("SELECT", escape(select, collapse = ", ", 
        con = con))
        }
    
    assertthat::assert_that(is.character(from), length(from) == 1L)
    out$from <- build_sql("FROM ", from, con = con)
    if (length(where) > 0L) {
        assertthat::assert_that(is.character(where))
        out$where <- build_sql("WHERE ", escape(where, collapse = " AND ", 
            con = con))
    }
    if (!is.null(group_by)) {
        assertthat::assert_that(is.character(group_by), length(group_by) > 
            0L)
        out$group_by <- build_sql("GROUP BY ", escape(group_by, 
            collapse = ", ", con = con))
    }
    if (!is.null(having)) {
        assertthat::assert_that(is.character(having), length(having) == 1L)
        out$having <- build_sql("HAVING ", escape(having, collapse = ", ", 
            con = con))
    }
    if (!is.null(order_by)) {
        assertthat::assert_that(is.character(order_by), length(order_by) > 
            0L)
        out$order_by <- build_sql("ORDER BY ", escape(order_by, 
            collapse = ", ", con = con))
    }

    if (!is.null(offset)) {
        assertthat::assert_that(is.integer(offset), length(offset) == 1L)
        out$offset <- build_sql("OFFSET ", offset, con = con)
    }
    escape(unname(dplyr:::compact(out)), collapse = "\n", parens = FALSE, 
        con = con)
}
 

```


Try for real with our Access source. 

```{r}
library(DBI)
library(RODBCDBI)
library(dplyr)
x <- src_access("CountriesAccess1")

accesstable <- tbl(x, "Countries Table")
## filter
accesstable  %>% filter(ID == 1)

## group_by
accesstable %>% group_by(BranchesI)

## mutate
accesstable  %>% mutate(a = 1)

## arrange, but prints too many rows?
accesstable  %>% arrange(BranchesI) %>% filter(coordinatesI > 1434)

## summarize doesn't work 
# accesstable %>% group_by(BranchesI) %>% summarize(x = n())
# Source: Access  [@ACCESS:/ACCESS]
# From: <derived table> [?? x 2]
# 
# Error in .valueClassTest(ans, "data.frame", "fetch") : 
#   invalid value from generic function ‘fetch’, class “character”, expected “data.frame”
# In addition: Warning message:
# closing unused RODBC handle 4 
# 


```












